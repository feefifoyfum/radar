-- Supabase schema and RLS for radar
-- Safe defaults: RLS enabled everywhere; service_role key bypasses policies.

-- Tables
create table if not exists public.users (
  id bigint generated by default as identity primary key,
  username text unique not null,
  email text unique not null,
  hashed_password text not null,
  bio text,
  created_at timestamptz not null default now(),
  is_active boolean not null default true
);

create table if not exists public.posts (
  id bigint generated by default as identity primary key,
  title text,
  content text not null,
  image_url text,
  author_id bigint not null references public.users(id) on delete cascade,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- Indexes
create index if not exists idx_users_username on public.users(username);
create index if not exists idx_users_email on public.users(email);
create index if not exists idx_posts_author_id on public.posts(author_id);
create index if not exists idx_posts_created_at on public.posts(created_at desc);

-- Trigger to maintain updated_at
create or replace function public.set_current_timestamp()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

drop trigger if exists trg_posts_updated_at on public.posts;
create trigger trg_posts_updated_at
before update on public.posts
for each row execute function public.set_current_timestamp();

-- Enable RLS
alter table public.users enable row level security;
alter table public.posts enable row level security;

-- Policies
-- Users table
-- Only allow read of active users
drop policy if exists "Users read active" on public.users;
create policy "Users read active" on public.users
for select using (is_active = true);

-- Allow insert for any (API will use service_role key)
drop policy if exists "Users insert via service" on public.users;
create policy "Users insert via service" on public.users
for insert with check (true);

-- Allow self update
drop policy if exists "Users update self" on public.users;
create policy "Users update self" on public.users
for update using (auth.uid()::text = id::text) with check (auth.uid()::text = id::text);

-- Posts table
-- Read all posts
drop policy if exists "Posts read all" on public.posts;
create policy "Posts read all" on public.posts
for select using (true);

-- Insert posts for any (API will enforce auth)
drop policy if exists "Posts insert via service" on public.posts;
create policy "Posts insert via service" on public.posts
for insert with check (true);

-- Update/delete only by author
drop policy if exists "Posts update own" on public.posts;
create policy "Posts update own" on public.posts
for update using (author_id = auth.uid()) with check (author_id = auth.uid());

drop policy if exists "Posts delete own" on public.posts;
create policy "Posts delete own" on public.posts
for delete using (author_id = auth.uid());

-- Notes:
-- If you are not using Supabase Auth (no JWT from Supabase),
-- the backend should use the service_role key and will bypass RLS.
-- These policies still allow safe read patterns if you expose anon key to frontend.


